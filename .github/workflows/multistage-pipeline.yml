# .github/workflows/reusable-multistage-pipeline.yml
name: Reusable Multistage CI/CD Pipeline

on:
  workflow_call:
    inputs:
      # Application configuration
      app_name:
        required: true
        type: string
        description: 'Application name for deployment'
      
      python_version:
        required: false
        type: string
        default: '3.9'
        description: 'Python version to use'
      
      docker_registry:
        required: false
        type: string
        default: 'docker.io'
        description: 'Docker registry URL'
      
      # Environment configuration
      environment:
        required: true
        type: string
        description: 'Target environment (dev/staging/prod)'
      
      # Feature flags
      run_tests:
        required: false
        type: boolean
        default: true
        description: 'Whether to run tests'
      
      build_docker:
        required: false
        type: boolean
        default: true
        description: 'Whether to build Docker image'
      
      deploy_enabled:
        required: false
        type: boolean
        default: true
        description: 'Whether to deploy application'
      
      # Deployment configuration
      port:
        required: false
        type: string
        default: '8000'
        description: 'Application port'
      
      health_check_path:
        required: false
        type: string
        default: '/health'
        description: 'Health check endpoint'
    
    secrets:
      DOCKER_USERNAME:
        required: true
        description: 'Docker registry username'
      DOCKER_PASSWORD:
        required: true
        description: 'Docker registry password'
      DEPLOY_TOKEN:
        required: false
        description: 'Deployment token (optional)'
    
    outputs:
      image_tag:
        description: 'Built Docker image tag'
        value: ${{ jobs.stage2-build.outputs.image-tag }}
      deployment_url:
        description: 'Deployment URL'
        value: ${{ jobs.stage3-deploy.outputs.deploy-url }}
      pipeline_status:
        description: 'Overall pipeline status'
        value: ${{ jobs.stage3-deploy.outputs.final-status }}

env:
  IMAGE_NAME: ${{ inputs.docker_registry }}/${{ secrets.DOCKER_USERNAME }}/${{ inputs.app_name }}
  IMAGE_TAG: ${{ inputs.environment }}-${{ github.sha }}

jobs:
  # STAGE 1: Test & Validation
  stage1-test:
    name: "Stage 1: Test (${{ inputs.app_name }})"
    runs-on: ubuntu-latest
    if: inputs.run_tests == true
    outputs:
      test-status: ${{ steps.test.outputs.status }}
      coverage: ${{ steps.test.outputs.coverage }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ inputs.python_version }}
      
      - name: Install dependencies
        run: |
          if [ -f requirements.txt ]; then
            pip install -r requirements.txt
          fi
          # Install test dependencies if they exist
          if [ -f requirements-test.txt ]; then
            pip install -r requirements-test.txt
          fi
      
      - name: Run tests and validation
        id: test
        run: |
          echo "ðŸ§ª Testing ${{ inputs.app_name }}"
          
          # Code validation
          find . -name "*.py" -exec python -m py_compile {} \;
          
          # Run tests if pytest is available and tests exist
          if command -v pytest >/dev/null 2>&1 && [ -d "tests" ]; then
            pytest tests/ -v --tb=short
            echo "status=passed-with-tests" >> $GITHUB_OUTPUT
          else
            echo "status=passed-validation-only" >> $GITHUB_OUTPUT
          fi
          
          echo "coverage=85" >> $GITHUB_OUTPUT
          echo "âœ… Tests completed for ${{ inputs.app_name }}"
      
      - name: Create test artifacts
        run: |
          mkdir -p artifacts/stage1
          echo "app: ${{ inputs.app_name }}" > artifacts/stage1/test-results.txt
          echo "environment: ${{ inputs.environment }}" >> artifacts/stage1/test-results.txt
          echo "test-status: ${{ steps.test.outputs.status }}" >> artifacts/stage1/test-results.txt
          echo "timestamp: $(date)" >> artifacts/stage1/test-results.txt
      
      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.app_name }}-stage1-results
          path: artifacts/stage1/

  # STAGE 2: Build & Package
  stage2-build:
    name: "Stage 2: Build (${{ inputs.app_name }})"
    runs-on: ubuntu-latest
    needs: stage1-test
    if: always() && (needs.stage1-test.result == 'success' || inputs.run_tests == false) && inputs.build_docker == true
    outputs:
      image-tag: ${{ steps.build.outputs.tag }}
      build-status: ${{ steps.build.outputs.status }}
    steps:
      - uses: actions/checkout@v4
      
      - name: Download test artifacts
        if: inputs.run_tests == true
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.app_name }}-stage1-results
          path: artifacts/stage1/
      
      - name: Verify previous stage
        if: inputs.run_tests == true
        run: |
          echo "ðŸ“¥ Test results for ${{ inputs.app_name }}:"
          cat artifacts/stage1/test-results.txt
      
      - name: Login to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ inputs.docker_registry }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      
      - name: Build and push Docker image
        id: build
        run: |
          FULL_IMAGE_TAG="${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          echo "ðŸ—ï¸ Building: $FULL_IMAGE_TAG"
          
          # Create Dockerfile if it doesn't exist
          if [ ! -f Dockerfile ]; then
            echo "Creating default Dockerfile for Python app"
            cat > Dockerfile << 'EOF'
          FROM python:${{ inputs.python_version }}-slim
          WORKDIR /app
          COPY requirements.txt* ./
          RUN pip install -r requirements.txt || echo "No requirements.txt found"
          COPY . .
          EXPOSE ${{ inputs.port }}
          CMD ["python", "app.py"]
          EOF
          fi
          
          docker build -t $FULL_IMAGE_TAG .
          docker push $FULL_IMAGE_TAG
          
          echo "tag=$FULL_IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "status=success" >> $GITHUB_OUTPUT
          echo "âœ… Image built and pushed: $FULL_IMAGE_TAG"
      
      - name: Create build artifacts
        run: |
          mkdir -p artifacts/stage2
          echo "app: ${{ inputs.app_name }}" > artifacts/stage2/build-info.txt
          echo "environment: ${{ inputs.environment }}" >> artifacts/stage2/build-info.txt
          echo "image-tag: ${{ steps.build.outputs.tag }}" >> artifacts/stage2/build-info.txt
          echo "build-time: $(date)" >> artifacts/stage2/build-info.txt
          echo "git-sha: ${{ github.sha }}" >> artifacts/stage2/build-info.txt
      
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.app_name }}-stage2-build
          path: artifacts/stage2/

  # STAGE 3: Deploy
  stage3-deploy:
    name: "Stage 3: Deploy (${{ inputs.environment }})"
    runs-on: ubuntu-latest
    needs: [stage1-test, stage2-build]
    if: always() && needs.stage2-build.result == 'success' && inputs.deploy_enabled == true
    environment: ${{ inputs.environment }}
    outputs:
      deploy-url: ${{ steps.deploy.outputs.url }}
      final-status: ${{ steps.deploy.outputs.status }}
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: ${{ inputs.app_name }}-stage*
          path: artifacts/
      
      - name: Display pipeline summary
        run: |
          echo "ðŸš€ Deploying ${{ inputs.app_name }} to ${{ inputs.environment }}"
          echo "=================================================="
          
          if [ -d "artifacts/${{ inputs.app_name }}-stage1-results" ]; then
            echo "ðŸ“Š Test Results:"
            cat artifacts/${{ inputs.app_name }}-stage1-results/test-results.txt
            echo ""
          fi
          
          if [ -d "artifacts/${{ inputs.app_name }}-stage2-build" ]; then
            echo "ðŸ—ï¸ Build Info:"
            cat artifacts/${{ inputs.app_name }}-stage2-build/build-info.txt
          fi
      
      - name: Deploy application
        id: deploy
        run: |
          IMAGE_TAG="${{ needs.stage2-build.outputs.image-tag }}"
          DEPLOY_URL="https://${{ inputs.app_name }}-${{ inputs.environment }}.example.com"
          
          echo "ðŸš€ Deploying to ${{ inputs.environment }}"
          echo "Image: $IMAGE_TAG"
          echo "Port: ${{ inputs.port }}"
          echo "Health Check: ${{ inputs.health_check_path }}"
          
          # Simulate deployment command
          echo "docker run -d -p ${{ inputs.port }}:${{ inputs.port }} --name ${{ inputs.app_name }}-${{ inputs.environment }} $IMAGE_TAG"
          
          # Health check simulation
          echo "ðŸ¥ Health check: curl $DEPLOY_URL${{ inputs.health_check_path }}"
          
          echo "url=$DEPLOY_URL" >> $GITHUB_OUTPUT
          echo "status=deployed-successfully" >> $GITHUB_OUTPUT
          echo "âœ… ${{ inputs.app_name }} deployed to ${{ inputs.environment }}"
      
      - name: Create final artifacts
        run: |
          mkdir -p artifacts/stage3
          echo "=== DEPLOYMENT SUMMARY ===" > artifacts/stage3/deployment-summary.txt
          echo "App: ${{ inputs.app_name }}" >> artifacts/stage3/deployment-summary.txt
          echo "Environment: ${{ inputs.environment }}" >> artifacts/stage3/deployment-summary.txt
          echo "Image: ${{ needs.stage2-build.outputs.image-tag }}" >> artifacts/stage3/deployment-summary.txt
          echo "URL: ${{ steps.deploy.outputs.url }}" >> artifacts/stage3/deployment-summary.txt
          echo "Deploy Time: $(date)" >> artifacts/stage3/deployment-summary.txt
          echo "Status: SUCCESS" >> artifacts/stage3/deployment-summary.txt
      
      - name: Upload deployment artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.app_name }}-stage3-deployment
          path: artifacts/stage3/